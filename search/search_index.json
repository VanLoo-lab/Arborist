{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Arborist is a method to rank SNV clone trees inferred from bulk DNA sequencing data by leveraging low-pass single-cell DNA sequencing (scDNA-seq) data. The method is designed to prioritize the most probable tree, helping to resolve ambiguities in bulk tree inference. Arborist uses variational inference to compute the evidence lower bound on the posterior probability of each tree in the input candidate set and approximates the cell to clone assignment posterior distribution as well as the SNV to SNV cluster assignment posterior. Arborist not only helps to resolve tree ambiguity within the bulk solution space but also helps improve an SNV cluster and yields a natural way to genotype single-cells and derive cell-to-clone assignments for downstream analysis.</p> <p></p> <p>For the code repository, visit Github.</p>"},{"location":"installation/","title":"Installation guide","text":"<p>The <code>arborist</code> package can be installed either via conda (recommended) or manually via <code>pip</code>.  Both methods will automatically install dependencies</p>"},{"location":"installation/#installation-via-conda-recommended","title":"Installation via conda (recommended)","text":"<p>COMING SOON!</p> <p><code>arborist</code> is available on Bioconda. You can easy install it via <code>conda/mamba</code> with:</p> <pre><code>conda install -c bioconda -c conda-forge arborist\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual installation","text":"<p>Clone the repository and install the package using <code>pip</code>. Note: dependencies will be installed automatically</p> <pre><code>git clone https://github.com/VanLoo-lab/Arborist.git\ncd Arborist\npip install .\n\n</code></pre>"},{"location":"installation/#testing-the-installation","title":"Testing the installation","text":"<p>To test the installation of the CLI tool and Python package, run the following:</p> <pre><code>arborist -h\npython -c \"from arborist import arborist\"\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The <code>arborist</code> package requires the following dependencies:</p> <ul> <li><code>python&gt;=3.7</code></li> <li><code>numpy&gt;=1.20</code></li> <li><code>scipy&gt;=1.7</code></li> <li><code>pandas&gt;=1.3</code></li> <li><code>pygraphviz</code></li> <li><code>numba&gt;=0.61</code></li> <li><code>networkx&gt;=3.6</code></li> </ul>"},{"location":"io/","title":"I/O Formats","text":""},{"location":"io/#input-data","title":"Input Data","text":"<p>Example input files can be found in the example/input directory.</p> <p>Arborist requires three inputs as three separate files:  </p> <ol> <li>a CSV file containing single-cell variant A and total D read count data</li> <li>a CSV file containing the initial SNV clustering</li> <li>a text file containing the set of candidate clone trees</li> </ol>"},{"location":"io/#read-counts-file-format","title":"Read Counts File Format","text":"<p>The input read counts file should be in CSV format contain the following columns with header row in any order:</p> Column Description <code>cell</code> cell identifier, str or int <code>snv</code> SNV identifier, str or int <code>total</code> Total number of reads for cell and SNV <code>alt</code> Number of variant reads for cell and SNV <p>Example</p> <pre><code>snv,cell,alt,total\n0,4,0,1\n0,5,0,1\n0,29,0,1\n0,45,0,1\n0,48,0,1\n0,64,0,1\n0,76,0,1\n0,92,0,1\n0,97,0,1\n</code></pre>"},{"location":"io/#initial-snv-clustering-file-format","title":"Initial SNV Clustering File Format","text":"<p>The initial SNV clustering file should be in CSV format and contain no headers. The order of the columns matter with the first column being the SNV identifier followed by the initial SNV cluster label. SNV identifiers should be consistent with the read count file and cluster labels should be consistent with the node labels in the candidate tree. Any SNV assigned to an SNV cluster label that is not present in the tree with be initialized with a uniform prior over all SNV clusters. </p> Column Description <code>snv</code> SNV identifier, str or int <code>cluster</code> SNV cluster label, int <p>Example</p> <pre><code>108,2\n123,2\n176,2\n289,2\n452,2\n597,2\n857,2\n890,2\n909,2\n918,2\n</code></pre>"},{"location":"io/#tree-file-format","title":"Tree File Format","text":"<ul> <li>The header for each tree, i.e., '# Tree 1'  must contain '#' but the remaining text is unimportant.</li> <li>Each tree consists of delimited separated parent-child relationships. The <code>arborist</code> default delimiter is \" \" but alternative delimiters may be passed via the <code>--edge-delim</code> argument. </li> <li>If input clone trees do not contain a normal clone (this is common), then the argument <code>--add-normal</code> should be used to tell <code>arborist</code> to append a normal clone to the root of each clone tree. Any cells assigned to the root will be inferred normal cells. </li> <li>Node identifiers must be integers.</li> </ul> <p>Example:</p> <pre><code>    # Tree 1\n    1 2\n    1 3\n    # Tree 2\n    4 5\n    4 6\n</code></pre>"},{"location":"io/#output-data","title":"Output Data","text":"<p>Some example output files are located in the example/output directory. Below is table describing the optional output files from <code>arborist</code></p> argument Description <code>--pickle</code> A pickled dictionary with tree index as key and <code>TreeFit</code> objects containing the fit for each clone tree <code>--draw</code> A visualization of the <code>arborist</code> top ranked clone tree <code>--tree</code> A flat text file similar to the input format containing the <code>arborist</code> top ranked clone tree <code>--ranking</code> a CSV file containg the ranking of the clone trees by the ELBO from best to worst. 'tree_idx' is the order listed in the candidate set <code>--cell-assign</code> a CSV file containing the MAP assignment of cell (id) to clone (assignment) <code>--snv-assign</code> a CSV file containing the MAP assignment of SNV (id) to cluster (assignment) <code>--q_z</code> a CSV file containing the approximate posterior distribution over cell-to-clone labels <code>--q_y</code> a CSV file containing the approximate posterior distribution over SNV-to-cluster labels"},{"location":"package-tutorial/","title":"Package Tutorial","text":"<p>Arborist is also a Python package. Below is an example of how to use it.</p>"},{"location":"package-tutorial/#running-the-arborist-function","title":"Running the <code>arborist</code> function","text":"<pre><code>import pandas as pd \nfrom arborist import read_trees, arborist \n\n#read the trees in as edge lists \ncandidate_trees = read_trees(\"example/input/candidate_trees.txt\")\nprint(f\"Candidate set size: {len(candidate_trees)}\")\n# Candidate set size: 30\n\nread_counts = pd.read_csv(\"example/input/read_counts.csv\")\nread_counts.head()\n\"\"\"\n&gt;&gt;&gt; read_counts.head()\n   snv  cell  alt  total\n0    0     4    0      1\n1    0     5    0      1\n2    0    29    0      1\n3    0    45    0      1\n\"\"\"\n\nsnv_clusters = pd.read_csv(\"example/input/input_clustering.csv\", header=None, names=[\"snv\", \"cluster\"]) \nsnv_clusters.head()\n\"\"\"\n&gt;&gt;&gt; snv_clusters.head()\n   snv  cluster\n0  108        2\n1  123        2\n2  176        2\n3  289        2\n4  452        2\n\"\"\"\n\nranking, best_fit, all_fits =arborist(\n    tree_list = candidate_trees,\n    read_counts = read_counts,\n    snv_clusters = snv_clusters,\n    alpha = 0.001,\n    max_iter = 10,\n    tolerance = 1,\n    gamma= 0.7,\n    add_normal = False,\n    threads = 10,\n    verbose = False\n)\n\nprint(best_fit)\n\"\"\"\nTree 0\nELBO: -311397.27\n 2-&gt;1\n 2-&gt;3\n 2-&gt;4\n 2-&gt;5\n 3-&gt;6\n 0-&gt;2\n\"\"\"\n\n</code></pre>"},{"location":"package-tutorial/#manipulating-treefit-objects-generated-by-arborist","title":"Manipulating <code>TreeFit</code> objects generated by <code>arborist</code>","text":"<p><code>TreeFit</code> objects can be used to obtain MAP assignments of cell-to-clone labels (<code>z</code>) or SNV-to-cluster labels (<code>y</code>) as well as explore the approximate posterior distributions (<code>qz</code>) and (<code>qy</code>)</p> <pre><code>\n#TreeFit \nz = best_fit.map_assign_z()\nz.head()\ny = best_fit.map_assign_y()\ny.head()\n\nqz = best_fit.q_z_df()\nqz.head()\nqy = best_fit.q_y_df()\nqy.head()\n\n\n</code></pre>"},{"location":"usage/","title":"Arborist CLI tool","text":"<p>After installation, <code>arborist</code> can be run via the command line with the following usage:</p> <pre><code>$ arborist -h                                                        \nusage: arborist [-h] -R READ_COUNTS -Y SNV_CLUSTERS -T TREES [--edge-delim EDGE_DELIM] [--add-normal] [--alpha ALPHA] [--max-iter MAX_ITER] [--prior PRIOR]\n                [--pickle PICKLE] [-d DRAW] [-t TREE] [--ranking RANKING] [--cell-assign CELL_ASSIGN] [--snv-assign SNV_ASSIGN] [--q_y Q_Y] [--q_z Q_Z]\n                [-j THREADS] [-v]\n\nArborist: a method to rank SNV clonal trees using scDNA-seq data.\n\noptions:\n  -h, --help            show this help message and exit\n  -R READ_COUNTS, --read_counts READ_COUNTS\n                        Path to read counts CSV file with columns 'snv', 'cell', 'total', 'alt'\n  -Y SNV_CLUSTERS, --snv-clusters SNV_CLUSTERS\n                        Path to SNV clusters CSV file with unlabeled columns 'snv', 'cluster'. The order of columns matters\n  -T TREES, --trees TREES\n                        Path to file containing all candidate trees to be ranked.\n  --edge-delim EDGE_DELIM\n                        edge delimiter in candidate tree file.\n  --add-normal          flag to add a normal clone if input trees do not already contain them\n  --alpha ALPHA         Per base sequencing error\n  --max-iter MAX_ITER   max number of iterations\n  --prior PRIOR         prior (gamma) on input SNV cluster assignment\n  --pickle PICKLE       path to where all pickled tree fits should be saved.\n  -d DRAW, --draw DRAW  Path to where the tree visualization should be saved\n  -t TREE, --tree TREE  Path to save the top ranked tree as a txt file.\n  --ranking RANKING     Path to where tree ranking output should be saved\n  --cell-assign CELL_ASSIGN\n                        Path to where the MAP cell-to-clone labels should be saved\n  --snv-assign SNV_ASSIGN\n                        Path to where the MAP SNV-to-cluster labels should be saved.\n  --q_y Q_Y             Path to where the approximate SNV posterior should be saved\n  --q_z Q_Z             Path to where the approximate cell posterior should be saved\n  -j THREADS, --threads THREADS\n                        Number of threads to use\n  -v, --verbose         Print verbose output\n</code></pre>"},{"location":"usage/#examples","title":"Examples","text":"<p>The following is a minimal <code>arborist</code> example with default parameters and no output files to test the installation.</p> <pre><code>   arborist -R example/input/read_counts.csv \\\n   -T example/input/candidate_trees.txt \\\n   -Y example/input/input_clustering.csv \n</code></pre> <p>If everything installed correctly you should see the following printout:</p> <pre><code>-----------Arborist complete!-----------\n\nTree index 0\nELBO: -311397.27\n 2-&gt;1\n 2-&gt;3\n 2-&gt;4\n 2-&gt;5\n 3-&gt;6\n 0-&gt;2\n</code></pre> <p>This example demonstrates how to modify parameters and write relevant output files. </p> <pre><code>   arborist -R example/input/read_counts.csv \\\n   -T example/input/candidate_trees.txt \\\n   -Y example/input/input_clustering.csv \\\n   --prior 0.7  \\\n   --alpha 0.001 \\\n   --ranking example/output/tree_rankings.csv \\\n   --draw example/output/best_tree.png \\\n   --cell-assign example/output/cell_to_clone_labels.csv \\\n   --snv-assign example/output/snv_to_cluster_labels.csv \n</code></pre>"},{"location":"api/arborist/","title":"arborist","text":"<p>Rank candidate SNV phylogenetic trees using scDNA-seq read counts.</p> <p>This function evaluates a list of clonal trees using a variational inference scheme and returns an evidence lower bound (ELBO)-based score for each tree. An initial SNV-to-cluster prior is set given an initial SNV clustering, and both cell-to-clone and SNV-to-cluster assignments are optimized under the model.</p> <p>Parameters:</p> Name Type Description Default <code>tree_list</code> <code>list of list of tuple</code> <p>Candidate phylogenetic trees to be ranked. Each tree is represented as a list of directed edges <code>(parent, child)</code>. All trees must contain the same set of clone identifiers.</p> required <code>read_counts</code> <code>DataFrame</code> <p>Data frame with columns <code>[\"snv\", \"cell\", \"alt\", \"total\"]</code> in any order,  containing per-cell read counts for each SNV.</p> required <code>snv_clusters</code> <code>DataFrame</code> <p>Data frame with columns <code>[\"snv\", \"cluster\"]</code> in any order, giving an initial hard assignment of SNVs to clusters.</p> required <code>alpha</code> <code>float</code> <p>Per-base sequencing error rate used to compute log-likelihoods for presence/absence of an SNV (default is <code>0.001</code>).</p> <code>0.001</code> <code>max_iter</code> <code>int</code> <p>Maximum number of coordinate-ascent iterations in the variational inference procedure (default is <code>10</code>).</p> <code>10</code> <code>tolerance</code> <code>float</code> <p>Convergence threshold on the change in ELBO between iterations (default is <code>1.0</code>).</p> <code>1</code> <code>gamma</code> <code>float</code> <p>Prior probability mass placed on the initial SNV cluster assignment in <code>q_y</code> (default is <code>0.7</code>). The remaining mass is spread uniformly over alternative clusters.</p> <code>0.7</code> <code>add_normal</code> <code>bool</code> <p>If <code>True</code>, prepend a normal clone as a new root node to each tree in <code>tree_list</code> (default is <code>False</code>).</p> <code>False</code> <code>threads</code> <code>int</code> <p>Number of threads to use for numba-parallelized computations (default is <code>10</code>).</p> <code>10</code> <code>verbose</code> <code>bool</code> <p>If <code>True</code>, enable informative logging messages during fitting (default is <code>False</code>).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>likelihoods</code> <code>dict[int, float]</code> <p>Mapping from tree index to its ELBO (expected log joint) under the variational posterior.</p> <code>best_fit</code> <code>TreeFit</code> <p><code>TreeFit</code> object for the top-ranked tree, containing the tree, ELBO, posterior cell-to-clone distribution <code>q_z</code>, posterior SNV-to-cluster distribution <code>q_y</code>, and associated index mappings.</p> <code>all_tree_fits</code> <code>dict[int, TreeFit]</code> <p>Dictionary mapping each tree index to its corresponding <code>TreeFit</code> object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the candidate trees in <code>tree_list</code> do not all share the same set of clone identifiers.</p> Notes <p>Only SNVs with at least one variant read across all cells are retained for inference. SNVs with zero total variant counts are dropped from <code>read_counts</code> before fitting.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; likelihoods, best_fit, all_fits = arborist(\n...     tree_list,\n...     read_counts,\n...     snv_clusters,\n...     alpha=0.001,\n...     max_iter=25,\n...     gamma=0.7,\n... )\n</code></pre> Source code in <code>src/arborist/arborist.py</code> <pre><code>def arborist(\n    tree_list: list,\n    read_counts: pd.DataFrame,\n    snv_clusters: pd.DataFrame,\n    alpha: float = 0.001,\n    max_iter: int = 10,\n    tolerance: float = 1,\n    gamma=0.7,\n    add_normal=False,\n    threads = 10,\n    verbose: bool = False,\n) -&gt; tuple:\n    \"\"\"\n    Rank candidate SNV phylogenetic trees using scDNA-seq read counts.\n\n    This function evaluates a list of clonal trees using a variational inference\n    scheme and returns an evidence lower bound (ELBO)-based score for each tree.\n    An initial SNV-to-cluster prior is set given an initial SNV clustering, and both cell-to-clone and\n    SNV-to-cluster assignments are optimized under the model.\n\n    Parameters\n    ----------\n    tree_list : list of list of tuple\n        Candidate phylogenetic trees to be ranked. Each tree is represented as\n        a list of directed edges ``(parent, child)``. All trees must contain\n        the same set of clone identifiers.\n    read_counts : pandas.DataFrame\n        Data frame with columns ``[\"snv\", \"cell\", \"alt\", \"total\"]`` in any order, \n        containing per-cell read counts for each SNV.\n    snv_clusters : pandas.DataFrame\n        Data frame with columns ``[\"snv\", \"cluster\"]`` in any order, giving an\n        initial hard assignment of SNVs to clusters.\n    alpha : float, optional\n        Per-base sequencing error rate used to compute log-likelihoods for\n        presence/absence of an SNV (default is ``0.001``).\n    max_iter : int, optional\n        Maximum number of coordinate-ascent iterations in the variational\n        inference procedure (default is ``10``).\n    tolerance : float, optional\n        Convergence threshold on the change in ELBO between iterations\n        (default is ``1.0``).\n    gamma : float, optional\n        Prior probability mass placed on the initial SNV cluster assignment\n        in ``q_y`` (default is ``0.7``). The remaining mass is spread\n        uniformly over alternative clusters.\n    add_normal : bool, optional\n        If ``True``, prepend a normal clone as a new root node to each tree in\n        ``tree_list`` (default is ``False``).\n    threads : int, optional\n        Number of threads to use for numba-parallelized computations\n        (default is ``10``).\n    verbose : bool, optional\n        If ``True``, enable informative logging messages during fitting\n        (default is ``False``).\n\n    Returns\n    -------\n    likelihoods : dict[int, float]\n        Mapping from tree index to its ELBO (expected log joint) under the\n        variational posterior.\n    best_fit : TreeFit\n        ``TreeFit`` object for the top-ranked tree, containing the tree,\n        ELBO, posterior cell-to-clone distribution ``q_z``, posterior\n        SNV-to-cluster distribution ``q_y``, and associated index mappings.\n    all_tree_fits : dict[int, TreeFit]\n        Dictionary mapping each tree index to its corresponding ``TreeFit``\n        object.\n\n    Raises\n    ------\n    ValueError\n        If the candidate trees in ``tree_list`` do not all share the same\n        set of clone identifiers.\n\n    Notes\n    -----\n    Only SNVs with at least one variant read across all cells are retained\n    for inference. SNVs with zero total variant counts are dropped from\n    ``read_counts`` before fitting.\n\n    Examples\n    --------\n    &gt;&gt;&gt; likelihoods, best_fit, all_fits = arborist(\n    ...     tree_list,\n    ...     read_counts,\n    ...     snv_clusters,\n    ...     alpha=0.001,\n    ...     max_iter=25,\n    ...     gamma=0.7,\n    ... )\n    \"\"\"\n\n\n    if verbose:\n        logger = logging.getLogger()\n\n    numba.set_num_threads(threads)\n\n    if add_normal:\n        if verbose:\n            logger.info(f\"Appending normal clone to candidate trees...\")\n        tree_list = add_normal_clone(tree_list)\n\n    tree = tree_list[0]\n\n    # assume root is normal\n    temp_tree = nx.DiGraph(tree)\n    normal = [n for n in temp_tree if temp_tree.in_degree(n) == 0][0]\n    clone_set = tree_to_clone_set(tree)\n    for tree in tree_list:\n        if tree_to_clone_set(tree) != clone_set:\n            raise ValueError(\"All trees must have the same set of clones.\")\n\n    clones = list(clone_set)\n\n    clusters = [c for c in clones if c != normal]\n\n    # Filter read_counts to only include cells and SNVs present in the tree\n\n    clones.sort()\n    clusters.sort()\n    clone_to_idx = {c: i for i, c in enumerate(clones)}\n    cluster_to_idx = {c: i for i, c in enumerate(clusters)}\n\n\n    if verbose:\n        logger.info(f\"Removing SNVs with 0 variant reads across all cells...\")\n\n    alt_sum = read_counts.groupby(\"snv\")[\"alt\"].sum()\n    valid_snvs = alt_sum[alt_sum &gt; 0].index\n\n\n    # valid SNVs are SNVs that have at least one variant read across all cells\n    # otherwise we have no signal to place them in the tree\n\n    read_counts = read_counts[read_counts[\"snv\"].isin(valid_snvs)].copy()\n\n    # appends columns log_absent and log_present to read_counts\n    if verbose:\n        logger.info(f\"Caching log-likelihoods for presence/absence...\")\n    read_counts, cell_to_idx, snv_to_idx = precompute_log_likelihoods(\n        read_counts, alpha\n    )\n\n    if verbose:\n        logger.info(f\"Initializing the SNV cluster assignment prior...\")\n    q_y_init = initialize_q_y(snv_clusters, cluster_to_idx, snv_to_idx, gamma)\n    cell_idx, snv_idx, log_like_matrix = build_sparse_input(\n        read_counts, cell_to_idx, snv_to_idx\n    )\n\n    n_cells = len(cell_to_idx)\n    n_snvs = len(snv_to_idx)\n    n_clones = len(clones)\n\n\n    cell_ptr, _, snv_index_cell_sort, log_like_matrix_cell_sort = (\n        build_index_pointers(\n            cell_idx, snv_idx, n_cells, log_like_matrix=log_like_matrix\n        )\n    )\n    snv_ptr, _ , cell_index_snv_sort, log_like_matrix_snv_sort = (\n        build_index_pointers(snv_idx, cell_idx, n_snvs, log_like_matrix=log_like_matrix)\n    )\n\n    best_likelihood = -np.inf\n    likelihoods = {}\n\n    all_tree_fits = {}\n\n    run = run_variational_inference\n\n    if verbose:\n        logger.info(f\"Starting Arborist...\")\n        logger.info(f\"Number of candidate trees: {len(tree)}\")\n        logger.info(f\"Number of clones: {n_clones}\")\n        logger.info(f\"Number of SNV clusters: {len(cluster_to_idx)}\")\n        logger.info(f\"Number of cells: {n_cells}\")\n        logger.info(f\"Number of SNVs: {n_snvs}\")\n    # else:\n    #     print(\"Running Arborist in cell MAP assignment mode....\")\n    #     run = run_simple_max_likelihood\n\n    for idx, tree in enumerate(tree_list):\n\n        presence = enumerate_presence(tree, clone_to_idx, cluster_to_idx)\n\n        expected_log_like, q_z, q_y = run(\n            presence,\n            log_like_matrix_cell_sort,\n            log_like_matrix_snv_sort,\n            cell_idx=cell_index_snv_sort,\n            snv_idx=snv_index_cell_sort,\n            n_cells=n_cells,\n            n_snvs=n_snvs,\n            n_clones=n_clones,\n            q_y_init=q_y_init,\n            cell_ptr=cell_ptr,\n            snv_ptr=snv_ptr,\n            max_iter=max_iter,\n            tolerance=tolerance,\n        )\n\n        tfit = TreeFit(\n            tree_list[idx],\n            idx,\n            expected_log_like,\n            q_z,\n            q_y,\n            cell_to_idx,\n            snv_to_idx,\n            clone_to_idx,\n            cluster_to_idx,\n        )\n        all_tree_fits[idx] = tfit\n        if verbose:\n            logger.info(f\"Tree {idx} fit wtih ELBO: {expected_log_like:.2f}\")\n        likelihoods[idx] = expected_log_like\n        if expected_log_like &gt; best_likelihood:\n            best_fit = tfit\n            best_likelihood = expected_log_like\n\n    if verbose:\n        logger.info(f\"Done fitting all {len(tree_list)} candidate trees!\")\n    return likelihoods, best_fit, all_tree_fits\n</code></pre>"},{"location":"api/read_trees/","title":"read_trees","text":"<p>Reads tree edges from a file and organizes them into a list of trees.</p> <p>Each tree is represented as a list of tuples, where each tuple contains two integers representing a parent-child relationship. Trees are separated by empty lines or comment lines (lines starting with <code>#</code>) in the file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file containing tree edge data. The file should have edge delimited integers on each line representing parent-child relationships.</p> required <code>sep</code> <code>str</code> <p>The delimiter between parent and child in the input file (default is <code>\" \"</code>).</p> <code>' '</code> <p>Returns:</p> Type Description <code>list of list of tuple of int</code> <p>A list of trees, where each tree is a list of tuples. Each tuple contains two integers representing a parent-child relationship.</p> Notes <ul> <li>Empty lines and lines starting with <code>#</code> are treated as separators   between trees.</li> <li>If the file ends without a separator, the last tree is still included   in the output.</li> </ul> <p>Examples:</p> <p>Given a file <code>path/to/file</code> with the following content:</p> <pre><code># Tree 1\n1 2\n1 3\n# Tree 2\n1 2\n2 3\n</code></pre> <pre><code>&gt;&gt;&gt; read_trees(\"path/to/file\")\n[[(1, 2), (1, 3)], [(4, 5), (4, 6)]]\n</code></pre> Source code in <code>src/arborist/utils.py</code> <pre><code>def read_trees(file_path, sep=\" \"):\n    \"\"\"\n    Reads tree edges from a file and organizes them into a list of trees.\n\n    Each tree is represented as a list of tuples, where each tuple contains\n    two integers representing a parent-child relationship. Trees are separated\n    by empty lines or comment lines (lines starting with `#`) in the file.\n\n    Parameters\n    ----------\n    file_path : str\n        The path to the file containing tree edge data. The file should have\n        edge delimited integers on each line representing parent-child\n        relationships.\n    sep : str, optional\n        The delimiter between parent and child in the input file (default is ``\" \"``).\n\n    Returns\n    -------\n    list of list of tuple of int\n        A list of trees, where each tree is a list of tuples. Each tuple\n        contains two integers representing a parent-child relationship.\n\n    Notes\n    -----\n    - Empty lines and lines starting with `#` are treated as separators\n      between trees.\n    - If the file ends without a separator, the last tree is still included\n      in the output.\n\n    Examples\n    --------\n    Given a file `path/to/file` with the following content:\n\n    ```\n    # Tree 1\n    1 2\n    1 3\n    # Tree 2\n    1 2\n    2 3\n    ```\n\n\n\n    &gt;&gt;&gt; read_trees(\"path/to/file\")\n    [[(1, 2), (1, 3)], [(4, 5), (4, 6)]]\n    \"\"\"\n    trees = []\n    current_tree = []\n\n    with open(file_path, \"r\") as file:\n        for line in file:\n            line = line.strip()\n            if not line or \"#\" in line:  # Skip empty lines and comments\n                if current_tree:  # Store previous tree before starting a new one\n                    trees.append(current_tree)\n                    current_tree = []\n                continue\n\n            # Convert space-separated numbers to tuple (parent, child)\n            parts = line.split(sep)\n            if len(parts) == 2:\n                current_tree.append((int(parts[0]), int(parts[1])))\n\n    if current_tree:  # Append last tree if exists\n        trees.append(current_tree)\n\n    return trees\n</code></pre>"},{"location":"api/treefit/","title":"TreeFit","text":"<p>Solution class to hold the solution for each tree fit by Arborist</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>list of tuples of int</code> <p>Edge list of tree including normal clone.</p> <code>tree_idx</code> <code>int</code> <p>Index identifier of tree in the original input</p> <code>elbo</code> <code>float</code> <p>The evidence lower bound (ELBO) computed for the tree.</p> <code>q_z</code> <code>ndarray</code> <p>The inferred approximation to the posterior cell-to-clone label.</p> <code>q_y</code> <code>ndarray</code> <p>The inferred approximation to the posterior SNV-to-cluster label.</p> <code>cell_to_idx.</code> <code>dict[str, int]</code> <p>The internal mapping of cell label to index.</p> <code>snv_to_idx</code> <code>dict[str, int]</code> <p>The internal mapping of SNV label to index.</p> <code>clone_to_idx</code> <code>dict[str, int]</code> <p>The internal mapping of clone label to index.</p> <code>cluster_to_idx</code> <code>dict[str, int]</code> <p>The internal mapping of SNV cluster label to index.</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>@dataclass\nclass TreeFit:\n    \"\"\"\n    Solution class to hold the solution for each tree fit by Arborist\n\n    Attributes\n    -----------\n    tree : list of tuples of int\n        Edge list of tree including normal clone.\n    tree_idx : int \n        Index identifier of tree in the original input\n    elbo : float\n        The evidence lower bound (ELBO) computed for the tree.\n    q_z : numpy.ndarray\n        The inferred approximation to the posterior cell-to-clone label.\n    q_y : numpy.ndarray\n        The inferred approximation to the posterior SNV-to-cluster label.\n    cell_to_idx. : dict[str,int]\n        The internal mapping of cell label to index.\n    snv_to_idx : dict[str,int]\n        The internal mapping of SNV label to index.\n    clone_to_idx : dict[str,int]\n        The internal mapping of clone label to index.\n    cluster_to_idx : dict[str,int]\n        The internal mapping of SNV cluster label to index.\n\n    \"\"\"\n\n    tree: list   \n    tree_idx: int \n    elbo: float \n    q_z: np.ndarray \n    q_y: np.ndarray #the inferred approximation to the posterior SNV-to-cluster label\n    cell_to_idx: dict #internal cell label to index \n    snv_to_idx: dict #intenal SNV label to index\n    clone_to_idx: dict #internal clone label to index\n    cluster_to_idx: dict #interal SNV cluster label to index \n\n    def __post_init__(self):\n        self.idx_to_clone = {v: k for k, v in self.clone_to_idx.items()}\n        self.idx_to_cluster = {v: k for k, v in self.cluster_to_idx.items()}\n\n    def __str__(self):\n        mystr = f\"Tree {self.tree_idx}\\nELBO: {self.elbo:.2f}\\n\"\n        for u, v in self.tree:\n            mystr += f\" {u}-&gt;{v}\\n\"\n        return mystr\n\n    def _convert_q_to_dataframe(self, q, row_dict, col_dict, prefix=\"clone\"):\n        \"\"\"\n        converts q to a dataframe\n        \"\"\"\n        df = pd.DataFrame(q)\n        df.columns = [f\"{prefix}_{col_dict[i]}\" for i in range(q.shape[1])]\n        df.index.name = \"id\"\n        df.reset_index(inplace=True)\n        label_dict = {val: key for key, val in row_dict.items()}\n        df[\"id\"] = df[\"id\"].map(label_dict)\n\n        return df\n\n    def q_z_df(self):\n        \"\"\"\n        Converts q_z numpy array to panda.DataFrame\n        \"\"\"\n        df = self._convert_q_to_dataframe(self.q_z, self.cell_to_idx, self.idx_to_clone, prefix=\"clone\")\n\n        return df\n\n    def q_y_df(self):\n        \"\"\"\n        Converts q_z numpy array to panda.DataFrame\n        \"\"\"\n        df = self._convert_q_to_dataframe(self.q_y, self.snv_to_idx, self.idx_to_cluster, prefix=\"cluster\")\n\n        return df\n\n    def __repr__(self):\n        return f\"TreeFit(tree={self.tree}, tree_idx={self.tree_idx}, expected_log_likelihood={self.elbo})\"\n\n    @staticmethod\n    def _map_assign(q, mydict, assign_dict):\n        \"\"\"\n        assigns cell to the maximum a posteriori (MAP) clone/cluster\n        \"\"\"\n        q_assign = q.argmax(axis=1)\n        q_assign = [assign_dict[val] for val in q_assign]\n\n        q_df = pd.DataFrame(q_assign, columns=[\"assignment\"])\n        q_df.index.name = \"id\"\n        q_df.reset_index(inplace=True)\n        label_dict = {val: key for key, val in mydict.items()}\n        q_df[\"id\"] = q_df[\"id\"].map(label_dict)\n\n        return q_df\n\n    def map_assign_z(self):\n        \"\"\"\n        assigns cell to the maximum a posteriori (MAP) clone\n\n        Returns\n        -------\n        pandas.DataFrame\n            A dataframe with columns ['id', 'assignment'] providing the cell-to-clone MAP assignment\n\n        \"\"\"\n        return self._map_assign(self.q_z, self.cell_to_idx, self.idx_to_clone)\n\n    def map_assign_y(self):\n        \"\"\"\n        assigns SNVs to the maximum a posteriori (MAP) cluster\n\n        Returns\n        -------\n        pandas.DataFrame\n            A dataframe with columns ['id', 'assignment'] providing the SNV-to-cluster MAP assignment\n        \"\"\"\n        return self._map_assign(self.q_y, self.snv_to_idx, self.idx_to_cluster)\n\n    def save_tree(self, fname, sep=\" \"):\n        \"\"\"\n        Write the tree as a flat file in the same format as in the input style.\n\n        Parameters\n        ----------\n        fname : str\n            The name of the output file to write the tree.\n        sep : str\n            The delimiter to use to separate parent and child (default is \" \").\n        \"\"\"\n        with open(fname, \"w+\") as file:\n            file.write(f\"{len(self.tree)} #edges tree 0\\n\")\n            for u, v in self.tree:\n                file.write(f\"{u}{sep}{v}\\n\")\n\n    def visualize_tree(self,  output_file=None):\n        \"\"\"\n        Visualizes a tree using Graphviz.\n\n        Parameters\n        ----------\n        output_file : str, optional\n            The path to save the visualization. If not provided, the visualization\n            will be displayed on the screen.        \n        \"\"\"\n        labels = defaultdict(str)\n\n\n        for parent, child in self.tree:\n            labels[parent] = f\"{parent}\"\n            labels[child] = f\"{child}\"\n\n\n\n        graph = pgv.AGraph(directed=True)\n\n        # Add nodes with labels and shapes\n        for parent, child in self.tree:\n            graph.add_node(parent, shape=\"circle\", label=labels[parent])\n            graph.add_node(child, shape=\"circle\", label=labels[child])\n            graph.add_edge(parent, child)\n\n        if output_file.endswith(\".dot\"):\n            graph.write(output_file)  # Save as a DOT file\n\n        elif output_file.endswith(\".png\"):\n            graph.draw(output_file, prog=\"dot\", format=\"png\")  # Save as a PNG\n\n    def _save_genotypes(self, fname, x=1, y=1):\n        \"\"\"\n        Write the genotypes of each clone to a file. Default copy numbers (x,y) are (1,1)\n        \"\"\"\n        snv_to_cluster_df = self.map_assign_y()\n        snv_to_cluster = dict(\n            zip(snv_to_cluster_df[\"id\"], snv_to_cluster_df[\"assignment\"])\n        )\n        tree = nx.DiGraph(self.tree)\n        root = [n for n in tree if len(list(tree.predecessors(n))) == 0][0]\n        geno_dict = {n: {} for n in tree}\n\n        for node in tree:\n            for cluster in tree:\n                if cluster != root:\n                    if node == cluster or tree.has_predecessor(node, cluster):\n                        geno_dict[node][cluster] = 1\n                    else:\n                        geno_dict[node][cluster] = 0\n                else:\n                    geno_dict[node][cluster] = 0\n        geno_list = []\n\n        for n in tree:\n            for j, clust in snv_to_cluster.items():\n                geno_list.append([n, j, x, y, geno_dict[n][clust], 0, 1])\n        geno_df = pd.DataFrame(\n            geno_list, columns=[\"node\", \"snv\", \"x\", \"y\", \"xbar\", \"ybar\", \"segment\"]\n        )\n        geno_df.to_csv(fname, index=False)\n\n    def cell_entropy(self, eps=1e-12):\n        \"\"\"\n        Computes the entropy of each cell assignment from the approximate variational posterior q_z\n        \"\"\"\n        row_dict = self.cell_to_idx\n        h_z = self._compute_hz(eps)\n        df = pd.DataFrame(h_z)\n        df.columns = [\"entropy\"]\n        df.index.name = \"id\"\n        df.reset_index(inplace=True)\n        label_dict = {val: key for key, val in row_dict.items()}\n        df[\"id\"] = df[\"id\"].map(label_dict)\n\n        return df\n\n    def snv_cluster_entropy(self, eps=1e-12):\n        \"\"\"\n        Computes the entropy of each SNV assignment from the approximate variational posterior q_y\n        \"\"\"\n        row_dict = self.snv_to_idx\n        h_y = self._compute_hy(eps)\n        assert h_y.shape[0] == len(row_dict)\n        df = pd.DataFrame(h_y)\n        df.columns = [\"entropy\"]\n        df.index.name = \"id\"\n        df.reset_index(inplace=True)\n        label_dict = {val: key for key, val in row_dict.items()}\n        df[\"id\"] = df[\"id\"].map(label_dict)\n\n        return df\n\n    def _compute_hz(self, eps=1e-12):\n        \"\"\"\n        Helper function to compute cell entropy\n        \"\"\"\n        h_z = -np.sum(self.q_z * np.log(self.q_z + eps), axis=1) / self.q_z.shape[1]\n        return h_z\n\n    def _compute_hy(self, eps=1e-12):\n        \"\"\"\n        Helper function to compute SNV entropy\n        \"\"\"\n        h_y = -np.sum(self.q_y * np.log(self.q_y + eps), axis=1) / self.q_y.shape[1]\n        return h_y\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.cell_entropy","title":"<code>cell_entropy(eps=1e-12)</code>","text":"<p>Computes the entropy of each cell assignment from the approximate variational posterior q_z</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def cell_entropy(self, eps=1e-12):\n    \"\"\"\n    Computes the entropy of each cell assignment from the approximate variational posterior q_z\n    \"\"\"\n    row_dict = self.cell_to_idx\n    h_z = self._compute_hz(eps)\n    df = pd.DataFrame(h_z)\n    df.columns = [\"entropy\"]\n    df.index.name = \"id\"\n    df.reset_index(inplace=True)\n    label_dict = {val: key for key, val in row_dict.items()}\n    df[\"id\"] = df[\"id\"].map(label_dict)\n\n    return df\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.map_assign_y","title":"<code>map_assign_y()</code>","text":"<p>assigns SNVs to the maximum a posteriori (MAP) cluster</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with columns ['id', 'assignment'] providing the SNV-to-cluster MAP assignment</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def map_assign_y(self):\n    \"\"\"\n    assigns SNVs to the maximum a posteriori (MAP) cluster\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe with columns ['id', 'assignment'] providing the SNV-to-cluster MAP assignment\n    \"\"\"\n    return self._map_assign(self.q_y, self.snv_to_idx, self.idx_to_cluster)\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.map_assign_z","title":"<code>map_assign_z()</code>","text":"<p>assigns cell to the maximum a posteriori (MAP) clone</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with columns ['id', 'assignment'] providing the cell-to-clone MAP assignment</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def map_assign_z(self):\n    \"\"\"\n    assigns cell to the maximum a posteriori (MAP) clone\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe with columns ['id', 'assignment'] providing the cell-to-clone MAP assignment\n\n    \"\"\"\n    return self._map_assign(self.q_z, self.cell_to_idx, self.idx_to_clone)\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.q_y_df","title":"<code>q_y_df()</code>","text":"<p>Converts q_z numpy array to panda.DataFrame</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def q_y_df(self):\n    \"\"\"\n    Converts q_z numpy array to panda.DataFrame\n    \"\"\"\n    df = self._convert_q_to_dataframe(self.q_y, self.snv_to_idx, self.idx_to_cluster, prefix=\"cluster\")\n\n    return df\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.q_z_df","title":"<code>q_z_df()</code>","text":"<p>Converts q_z numpy array to panda.DataFrame</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def q_z_df(self):\n    \"\"\"\n    Converts q_z numpy array to panda.DataFrame\n    \"\"\"\n    df = self._convert_q_to_dataframe(self.q_z, self.cell_to_idx, self.idx_to_clone, prefix=\"clone\")\n\n    return df\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.save_tree","title":"<code>save_tree(fname, sep=' ')</code>","text":"<p>Write the tree as a flat file in the same format as in the input style.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>The name of the output file to write the tree.</p> required <code>sep</code> <code>str</code> <p>The delimiter to use to separate parent and child (default is \" \").</p> <code>' '</code> Source code in <code>src/arborist/treefit.py</code> <pre><code>def save_tree(self, fname, sep=\" \"):\n    \"\"\"\n    Write the tree as a flat file in the same format as in the input style.\n\n    Parameters\n    ----------\n    fname : str\n        The name of the output file to write the tree.\n    sep : str\n        The delimiter to use to separate parent and child (default is \" \").\n    \"\"\"\n    with open(fname, \"w+\") as file:\n        file.write(f\"{len(self.tree)} #edges tree 0\\n\")\n        for u, v in self.tree:\n            file.write(f\"{u}{sep}{v}\\n\")\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.snv_cluster_entropy","title":"<code>snv_cluster_entropy(eps=1e-12)</code>","text":"<p>Computes the entropy of each SNV assignment from the approximate variational posterior q_y</p> Source code in <code>src/arborist/treefit.py</code> <pre><code>def snv_cluster_entropy(self, eps=1e-12):\n    \"\"\"\n    Computes the entropy of each SNV assignment from the approximate variational posterior q_y\n    \"\"\"\n    row_dict = self.snv_to_idx\n    h_y = self._compute_hy(eps)\n    assert h_y.shape[0] == len(row_dict)\n    df = pd.DataFrame(h_y)\n    df.columns = [\"entropy\"]\n    df.index.name = \"id\"\n    df.reset_index(inplace=True)\n    label_dict = {val: key for key, val in row_dict.items()}\n    df[\"id\"] = df[\"id\"].map(label_dict)\n\n    return df\n</code></pre>"},{"location":"api/treefit/#arborist.treefit.TreeFit.visualize_tree","title":"<code>visualize_tree(output_file=None)</code>","text":"<p>Visualizes a tree using Graphviz.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>str</code> <p>The path to save the visualization. If not provided, the visualization will be displayed on the screen.</p> <code>None</code> Source code in <code>src/arborist/treefit.py</code> <pre><code>def visualize_tree(self,  output_file=None):\n    \"\"\"\n    Visualizes a tree using Graphviz.\n\n    Parameters\n    ----------\n    output_file : str, optional\n        The path to save the visualization. If not provided, the visualization\n        will be displayed on the screen.        \n    \"\"\"\n    labels = defaultdict(str)\n\n\n    for parent, child in self.tree:\n        labels[parent] = f\"{parent}\"\n        labels[child] = f\"{child}\"\n\n\n\n    graph = pgv.AGraph(directed=True)\n\n    # Add nodes with labels and shapes\n    for parent, child in self.tree:\n        graph.add_node(parent, shape=\"circle\", label=labels[parent])\n        graph.add_node(child, shape=\"circle\", label=labels[child])\n        graph.add_edge(parent, child)\n\n    if output_file.endswith(\".dot\"):\n        graph.write(output_file)  # Save as a DOT file\n\n    elif output_file.endswith(\".png\"):\n        graph.draw(output_file, prog=\"dot\", format=\"png\")  # Save as a PNG\n</code></pre>"}]}